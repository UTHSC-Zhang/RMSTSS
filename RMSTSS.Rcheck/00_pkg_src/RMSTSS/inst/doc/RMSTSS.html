<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Arnab Aich" />


<title>RMSTSS: Sample Size and Power Calculations for RMST-based Clinical Trials</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<style type="text/css">detaiks.chunk-details > summary.chunk-summary {
text-align: right;
}
details.chunk-details[open] > summary.chunk-summary::after {
content: "Hide";
}
details.chunk-details[open] > summary.chunk-summary > span.chunk-summary-text {
display: none;
}
</style>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } 
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.at { color: #204a87; } 
code span.bn { color: #0000cf; } 
code span.cf { color: #204a87; font-weight: bold; } 
code span.ch { color: #4e9a06; } 
code span.cn { color: #8f5902; } 
code span.co { color: #8f5902; font-style: italic; } 
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.dt { color: #204a87; } 
code span.dv { color: #0000cf; } 
code span.er { color: #a40000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #0000cf; } 
code span.fu { color: #204a87; font-weight: bold; } 
code span.im { } 
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.kw { color: #204a87; font-weight: bold; } 
code span.op { color: #ce5c00; font-weight: bold; } 
code span.ot { color: #8f5902; } 
code span.pp { color: #8f5902; font-style: italic; } 
code span.sc { color: #ce5c00; font-weight: bold; } 
code span.ss { color: #4e9a06; } 
code span.st { color: #4e9a06; } 
code span.va { color: #000000; } 
code span.vs { color: #4e9a06; } 
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">RMSTSS: Sample Size and Power Calculations
for RMST-based Clinical Trials</h1>
<h4 class="author">Arnab Aich</h4>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#core-concepts-of-rmstss-package" id="toc-core-concepts-of-rmstss-package">Core Concepts of
<code>RMSTSS</code> Package</a>
<ul>
<li><a href="#the-analytic-method-.analytical-functions" id="toc-the-analytic-method-.analytical-functions">The Analytic Method
(<code>.analytical</code> functions)</a></li>
<li><a href="#the-bootstrap-method-.boot-functions" id="toc-the-bootstrap-method-.boot-functions">The Bootstrap Method
(<code>.boot</code> functions)</a></li>
<li><a href="#the-sample-size-search-algorithm-.ss-functions" id="toc-the-sample-size-search-algorithm-.ss-functions">The Sample Size
Search Algorithm (<code>.ss</code> functions)</a></li>
<li><a href="#avaailable-functions-a-quick-guide" id="toc-avaailable-functions-a-quick-guide">Avaailable Functions: A
Quick Guide</a></li>
<li><a href="#selecting-an-appropriate-model" id="toc-selecting-an-appropriate-model">Selecting an Appropriate
Model</a></li>
</ul></li>
<li><a href="#linear-ipcw-models" id="toc-linear-ipcw-models">Linear
IPCW Models</a>
<ul>
<li><a href="#theory-and-model" id="toc-theory-and-model">Theory and
Model</a></li>
<li><a href="#analytical-methods" id="toc-analytical-methods">Analytical
Methods</a>
<ul>
<li><a href="#power-calculation---linear.power.analytical" id="toc-power-calculation---linear.power.analytical">Power Calculation -
<code>linear.power.analytical</code></a></li>
<li><a href="#sample-size-calculation---linear.ss.analytical" id="toc-sample-size-calculation---linear.ss.analytical">Sample Size
Calculation - <code>linear.ss.analytical</code></a></li>
</ul></li>
<li><a href="#bootstrap-methods" id="toc-bootstrap-methods">Bootstrap
Methods</a>
<ul>
<li><a href="#power-and-sample-size-calculation-.boot" id="toc-power-and-sample-size-calculation-.boot">Power and Sample Size
Calculation (<code>.boot</code>)</a></li>
</ul></li>
</ul></li>
<li><a href="#additive-stratified-models" id="toc-additive-stratified-models">Additive Stratified Models</a>
<ul>
<li><a href="#theory-and-model-1" id="toc-theory-and-model-1">Theory and
Model</a></li>
<li><a href="#analytical-methods-1" id="toc-analytical-methods-1">Analytical Methods</a>
<ul>
<li><a href="#sample-size-calculation---additive.ss.analytical" id="toc-sample-size-calculation---additive.ss.analytical">Sample Size
Calculation - <code>additive.ss.analytical</code></a></li>
<li><a href="#power-calculation---additive.power.analytical" id="toc-power-calculation---additive.power.analytical">Power Calculation
- <code>additive.power.analytical</code></a></li>
</ul></li>
</ul></li>
<li><a href="#multiplicative-stratified-models" id="toc-multiplicative-stratified-models">Multiplicative Stratified
Models</a>
<ul>
<li><a href="#theory-and-model-2" id="toc-theory-and-model-2">Theory and
Model</a></li>
<li><a href="#analytical-methods-2" id="toc-analytical-methods-2">Analytical Methods</a>
<ul>
<li><a href="#power-calculation---ms.power.analytical" id="toc-power-calculation---ms.power.analytical">Power Calculation -
<code>MS.power.analytical</code></a></li>
<li><a href="#sample-size-calculation---ms.ss.analytical" id="toc-sample-size-calculation---ms.ss.analytical">Sample Size
Calculation - <code>MS.ss.analytical</code></a></li>
</ul></li>
<li><a href="#bootstrap-methods-1" id="toc-bootstrap-methods-1">Bootstrap Methods</a>
<ul>
<li><a href="#power-calculation---ms.power.boot" id="toc-power-calculation---ms.power.boot">Power Calculation -
<code>MS.power.boot</code></a></li>
<li><a href="#sample-size-calculation---ms.ss.boot" id="toc-sample-size-calculation---ms.ss.boot">Sample Size Calculation -
<code>MS.ss.boot</code></a></li>
</ul></li>
</ul></li>
<li><a href="#semiparametric-gam-models" id="toc-semiparametric-gam-models">Semiparametric GAM Models</a>
<ul>
<li><a href="#theory-and-model-3" id="toc-theory-and-model-3">Theory and
Model</a>
<ul>
<li><a href="#power-calculation-formula-gam.power.boot" id="toc-power-calculation-formula-gam.power.boot">Power Calculation
Formula (<code>GAM.power.boot</code>)</a></li>
</ul></li>
<li><a href="#bootstrap-methods-2" id="toc-bootstrap-methods-2">Bootstrap Methods</a>
<ul>
<li><a href="#power-calculation---gam.power.boot" id="toc-power-calculation---gam.power.boot">Power Calculation -
<code>GAM.power.boot</code></a></li>
<li><a href="#sample-size-calculation---gam.ss.boot" id="toc-sample-size-calculation---gam.ss.boot">Sample Size Calculation -
<code>GAM.ss.boot</code></a></li>
</ul></li>
</ul></li>
<li><a href="#dependent-censoring-models" id="toc-dependent-censoring-models">Dependent Censoring Models</a>
<ul>
<li><a href="#theory-and-model-4" id="toc-theory-and-model-4">Theory and
Model</a>
<ul>
<li><a href="#power-calculation-formula-dc.power.analytical" id="toc-power-calculation-formula-dc.power.analytical">Power Calculation
Formula (<code>DC.power.analytical</code>)</a></li>
</ul></li>
<li><a href="#analytical-methods-3" id="toc-analytical-methods-3">Analytical Methods</a>
<ul>
<li><a href="#power-calculation---dc.power.analytical" id="toc-power-calculation---dc.power.analytical">Power Calculation -
<code>DC.power.analytical</code></a></li>
<li><a href="#sample-size-calculation---dc.ss.analytical" id="toc-sample-size-calculation---dc.ss.analytical">Sample Size
Calculation - <code>DC.ss.analytical</code></a></li>
</ul></li>
</ul></li>
<li><a href="#interactive-shiny-application" id="toc-interactive-shiny-application">Interactive Shiny Application</a>
<ul>
<li><a href="#accessing-the-application" id="toc-accessing-the-application">Accessing the Application</a></li>
<li><a href="#app-features" id="toc-app-features">App Features</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a>
<ul>
<li><a href="#advantages-and-disadvantages" id="toc-advantages-and-disadvantages">Advantages and
Disadvantages</a></li>
<li><a href="#future-work" id="toc-future-work">Future Work</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The analysis of time-to-event data often relies on the Cox
proportional hazards model, which uses the hazard ratio (HR) as its
primary result. However, the HR can be difficult to interpret,
especially when its core assumption of proportional hazards is not
met.</p>
<p>As an alternative, the <strong>Restricted Mean Survival Time
(RMST)</strong> is gaining favor for its clarity and robust properties
<span class="citation">(<a href="#ref-royston2013">Royston and Parmar
2013</a>; <a href="#ref-uno2014">Uno et al. 2014</a>)</span>. The RMST
measures the average event-free time up to a pre-specified follow-up
point, <strong>L</strong>. This provides a direct and meaningful measure
of treatment benefit (e.g., “an average of 3 extra months of survival
over 5 years”), which is highly valuable for clinicians and
patients.</p>
<p>Modern statistical methods now focus on modeling the RMST directly as
a function of covariates, rather than estimating it indirectly from a
survival curve. This direct approach, based on foundational work using
Inverse Probability of Censoring Weighting (IPCW) <span class="citation">(<a href="#ref-tian2014">Tian, Zhao, and Wei
2014</a>)</span>, has been extended to handle the complex data
structures seen in modern trials, including stratification <span class="citation">(<a href="#ref-wang2019">Wang et al. 2019</a>; <a href="#ref-zhang2024">Zhang and Schaubel 2024</a>)</span> and competing
risks <span class="citation">(<a href="#ref-wang2018">Wang and Schaubel
2018</a>)</span>.</p>
<p>However, most software tools for these advanced methods focus on
analyzing existing data, not designing new studies. This has left trial
statisticians to write custom code for the crucial task of calculating
sample size and power.</p>
<p>The <code>RMSTSS</code> package is designed to fill this gap. It
provides a comprehensive and user-friendly suite of tools for
<strong>power and sample size calculations</strong> based on the latest
direct RMST methodologies. The package implements several key approaches
from the statistical literature:</p>
<ul>
<li><strong>Direct Linear Models</strong>: The foundational IPCW-based
regression model for RMST <span class="citation">(<a href="#ref-tian2014">Tian, Zhao, and Wei 2014</a>)</span>.</li>
<li><strong>Stratified Models</strong>: Efficient methods for studies
with many strata (e.g., clinical centers), including both
<strong>additive</strong> <span class="citation">(<a href="#ref-zhang2024">Zhang and Schaubel 2024</a>)</span> and
<strong>multiplicative</strong> (<span class="citation">(<a href="#ref-wang2019">Wang et al. 2019</a>)</span>) models.</li>
<li><strong>Dependent Censoring Models</strong>: For handling competing
risks, based on methods from <span class="citation">(<a href="#ref-wang2018">Wang and Schaubel 2018</a>)</span>.</li>
<li><strong>Flexible Non-Linear Models</strong>: Bootstrap-based
functions using Generalized Additive Models (GAMs) to capture non-linear
covariate effects.</li>
<li><strong>Analytic vs. Bootstrap Methods</strong>: For most models,
the package offers a choice between a fast <code>analytical</code>
calculation and a robust, simulation-based <code>boot</code>
method.</li>
</ul>
<p>This vignette will guide you through the theory and application of
each of these function groups.</p>
<hr />
</div>
<div id="core-concepts-of-rmstss-package" class="section level1 tabset">
<h1 class="tabset">Core Concepts of <code>RMSTSS</code> Package</h1>
<p>The <code>RMSTSS</code> package uses two primary approaches for its
calculations: a fast <strong>Analytic Method</strong> and a robust
<strong>Bootstrap Method</strong>. All functions for finding sample size
then use a common search algorithm. Understanding these three components
is key to choosing the right function for your needs.</p>
<div id="the-analytic-method-.analytical-functions" class="section level2">
<h2>The Analytic Method (<code>.analytical</code> functions)</h2>
<p>The analytical functions are extremely fast because they use a direct
mathematical formula to calculate power. This makes them ideal for
quickly exploring different scenarios. The process is:</p>
<ol style="list-style-type: decimal">
<li><strong>One-Time Estimation</strong>: The function first analyzes
the provided <code>pilot_data</code> to estimate two key parameters:
<ul>
<li>The <strong>treatment effect size</strong> (e.g., the difference in
RMST or the log-RMST ratio).</li>
<li>The <strong>asymptotic variance</strong> of that effect estimator,
which measures its uncertainty.</li>
</ul></li>
<li><strong>Power Formula</strong>: It then plugs these fixed estimates
into a standard power formula. For a given total sample size
<code>N</code>, the power is calculated as: <span class="math display">\[
\text{Power} = \Phi\left( \frac{|\beta_{\text{effect}}|}{\sigma_N} -
z_{1-\alpha/2} \right)
\]</span> where:
<ul>
<li><span class="math inline">\(\Phi\)</span> is the cumulative
distribution function (CDF) of the standard normal distribution.</li>
<li><span class="math inline">\(\beta_{\text{effect}}\)</span> is the
treatment effect estimated from the pilot data.</li>
<li><span class="math inline">\(\sigma_N =
\frac{\sigma_1}{\sqrt{N}}\)</span> is the standard error of the effect
for the target sample size <code>N</code>, which is scaled from the
pilot data’s variance.</li>
<li><span class="math inline">\(z_{1-\alpha/2}\)</span> is the critical
value from the standard normal distribution (e.g., 1.96 for an alpha of
0.05).</li>
</ul></li>
</ol>
</div>
<div id="the-bootstrap-method-.boot-functions" class="section level2">
<h2>The Bootstrap Method (<code>.boot</code> functions)</h2>
<p>The bootstrap functions provide a robust, simulation-based
alternative that makes fewer assumptions about the data’s distribution.
This is a trade-off, as they are much more computationally intensive.
The process is:</p>
<ol style="list-style-type: decimal">
<li><strong>Resample</strong>: The function simulates a “future trial”
of a given <code>sample_size</code> by resampling with replacement from
the <code>pilot_data</code>.</li>
<li><strong>Fit Model</strong>: On this new bootstrap sample, it
performs the full analysis (e.g., calculating weights or
pseudo-observations and fitting the specified model).</li>
<li><strong>Get P-Value</strong>: It extracts the p-value for the
treatment effect from the fitted model.</li>
<li><strong>Repeat</strong>: This process is repeated thousands of times
(<code>n_sim</code>).</li>
<li><strong>Calculate Power</strong>: The final estimated power is the
proportion of simulations where the p-value was less than the
significance level <code>alpha</code>. <span class="math display">\[
\text{Power} = \frac{\text{Number of simulations with } p &lt;
\alpha}{n_{\text{sim}}}
\]</span></li>
</ol>
</div>
<div id="the-sample-size-search-algorithm-.ss-functions" class="section level2">
<h2>The Sample Size Search Algorithm (<code>.ss</code> functions)</h2>
<p>All functions ending in <code>.ss</code> (for sample size) use the
same iterative search algorithm to find the <code>N</code> required to
achieve a <code>target_power</code>:</p>
<ol style="list-style-type: decimal">
<li><strong>Start</strong>: The search begins with a sample size of
<code>n_start</code>.</li>
<li><strong>Calculate Power</strong>: It calculates the power for the
<code>current_n</code> using either the <strong>analytic
formula</strong> or a <strong>full bootstrap simulation</strong>.</li>
<li><strong>Check Condition</strong>:
<ul>
<li>If <code>calculated_power &gt;= target_power</code>, the search
succeeds and returns <code>current_n</code>.</li>
<li>If not, it increments the sample size
(<code>current_n = current_n + n_step</code>) and repeats the
process.</li>
</ul></li>
<li><strong>Stopping Rules</strong>: The search terminates if the sample
size exceeds <code>max_n_per_arm</code> or, for bootstrap methods, if
the power fails to improve for a set number of <code>patience</code>
steps.</li>
</ol>
</div>
<div id="avaailable-functions-a-quick-guide" class="section level2">
<h2>Avaailable Functions: A Quick Guide</h2>
<p>The package uses a consistent naming convention to help you select
the correct function. The names are combinations of the
<code>[Model Type]</code>, the <code>[Goal - power or ss]</code>, and
the <code>[Method - analytical or boot]</code>. The table below provides
a summary of the available functions for each model.</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Model Type</th>
<th align="left">Analytic Functions</th>
<th align="left">Bootstrap Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Linear IPCW</strong></td>
<td align="left"><code>linear.power.analytical</code>
<br><code>linear.ss.analytical</code></td>
<td align="left"><code>linear.power.boot</code>
<br><code>linear.ss.boot</code></td>
</tr>
<tr class="even">
<td align="left"><strong>Additive Stratified</strong></td>
<td align="left"><code>additive.power.analytical</code>
<br><code>additive.ss.analytical</code></td>
<td align="left"><em>Not applicable</em></td>
</tr>
<tr class="odd">
<td align="left"><strong>Multiplicative Stratified</strong></td>
<td align="left"><code>MS.power.analytical</code>
<br><code>MS.ss.analytical</code></td>
<td align="left"><code>MS.power.boot</code>
<br><code>MS.ss.boot</code></td>
</tr>
<tr class="even">
<td align="left"><strong>Semiparametric GAM</strong></td>
<td align="left"><em>Not applicable</em></td>
<td align="left"><code>GAM.power.boot</code>
<br><code>GAM.ss.boot</code></td>
</tr>
<tr class="odd">
<td align="left"><strong>Dependent Censoring</strong></td>
<td align="left"><code>DC.power.analytical</code>
<br><code>DC.ss.analytical</code></td>
<td align="left"><em>Not applicable</em></td>
</tr>
</tbody>
</table>
</div>
<div id="selecting-an-appropriate-model" class="section level2">
<h2>Selecting an Appropriate Model</h2>
<p>Model selection depends on the assumptions made about the data
structure and the design of the study. The following table summarizes
recommended modeling strategies under various analytical scenarios:</p>
<table>
<colgroup>
<col width="11%" />
<col width="28%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Model</th>
<th align="left">Key Assumption / Scenario</th>
<th align="left">Recommended Use Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Linear IPCW</strong></td>
<td align="left">Assumes a linear relationship between covariates and
RMST.</td>
<td align="left">Suitable for baseline analyses where there is no strong
evidence of non-linear effects or complex stratification.</td>
</tr>
<tr class="even">
<td align="left"><strong>Additive Stratified</strong></td>
<td align="left">Assumes the treatment adds a constant amount of
survival time across strata.</td>
<td align="left">Appropriate for multi-center trials where the treatment
effect is expected to be uniform (e.g., a fixed increase in survival
time across centers).</td>
</tr>
<tr class="odd">
<td align="left"><strong>Multiplicative Stratified</strong></td>
<td align="left">Assumes the treatment multiplies survival time
proportionally across strata.</td>
<td align="left">Preferred in multi-center trials where the treatment is
expected to produce proportional gains relative to baseline survival
across different centers.</td>
</tr>
<tr class="even">
<td align="left"><strong>Semiparametric GAM</strong></td>
<td align="left">Allows for non-linear covariate effects on RMST.</td>
<td align="left">Useful when variables (e.g., age, biomarker levels) are
believed to have complex, non-linear associations with the outcome.</td>
</tr>
<tr class="odd">
<td align="left"><strong>Dependent Censoring</strong></td>
<td align="left">Accounts for dependent censoring or competing
risks.</td>
<td align="left">Recommended for studies involving competing events,
such as transplant studies where receiving a transplant precludes
observation of pre-transplant mortality.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="linear-ipcw-models" class="section level1 tabset">
<h1 class="tabset">Linear IPCW Models</h1>
<p>These functions implement the foundational direct linear regression
model for the RMST. This model is appropriate when a linear relationship
between covariates and the RMST is assumed, and when censoring is
independent of the event of interest.</p>
<div id="theory-and-model" class="section level2">
<h2>Theory and Model</h2>
<p>Based on the methods of <span class="citation">(<a href="#ref-tian2014">Tian, Zhao, and Wei 2014</a>)</span>, these
functions model the conditional RMST as a linear function of covariates:
<span class="math display">\[\mathbb{E}[\min(T_i, L) | Z_i] = \beta_0 +
\beta_1 \text{Treatment}_i + \beta_2 \text{Covariate}_{i}\]</span> In
this model, the expected RMST up to a pre-specified time
<strong>L</strong> for subject <em>i</em> is modeled as a linear
combination of their treatment arm and other variables <span class="math inline">\(Z_i\)</span>.</p>
<p>To handle right-censoring, the method uses <strong>Inverse
Probability of Censoring Weighting (IPCW)</strong>. This is achieved
through the following steps:</p>
<ol style="list-style-type: decimal">
<li>A survival curve for the <strong>censoring distribution</strong> is
estimated using the Kaplan-Meier method (where “failure” is being
censored).</li>
<li>For each subject who experienced the primary event, a weight is
calculated. This weight is the inverse of the probability of
<em>not</em> being censored up to their event time.</li>
<li>A standard weighted linear model (<code>lm()</code>) is then fitted
using these weights. The model only includes subjects who experienced
the event.</li>
</ol>
</div>
<div id="analytical-methods" class="section level2">
<h2>Analytical Methods</h2>
<p>The analytical functions use a formula based on the asymptotic
variance of the regression coefficients to calculate power or sample
size, making them extremely fast.</p>
<p><strong>Scenario</strong>: We use the <code>veteran</code> dataset to
estimate power for a trial comparing standard vs. test chemotherapy
(<code>trt</code>), adjusting for the Karnofsky performance score
(<code>karno</code>).</p>
<div id="power-calculation---linear.power.analytical" class="section level3">
<h3>Power Calculation - <a href="../reference/linear.power.analytical.html"><code>linear.power.analytical</code></a></h3>
<p>First, lets inspect the prepared <code>veteran</code> dataset.</p>
<p>Now, we calculate the power for a range of sample sizes using a
truncation time of 9 months (270 days).</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>power_results_vet <span class="ot">&lt;-</span> <span class="fu">linear.power.analytical</span>(</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="at">pilot_data =</span> vet,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  <span class="at">linear_terms =</span> <span class="st">&quot;karno&quot;</span>,</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>  <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">200</span>, <span class="dv">250</span>),</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  <span class="at">L =</span> <span class="dv">270</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>)</span></code></pre></div>
</details>
<p>The results are returned as a data frame and a <code>ggplot</code>
object.</p>
</div>
<div id="sample-size-calculation---linear.ss.analytical" class="section level3">
<h3>Sample Size Calculation - <a href="../reference/linear.ss.analytical.html"><code>linear.ss.analytical</code></a></h3>
<p>We can also use the analytical method to find the required sample
size to achieve a target power for a truncation time of one year (365
days).</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>ss_results_vet <span class="ot">&lt;-</span> <span class="fu">linear.ss.analytical</span>(</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="at">pilot_data =</span> vet,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  <span class="at">target_power =</span> <span class="fl">0.40</span>,</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>  <span class="at">linear_terms =</span> <span class="st">&quot;karno&quot;</span>,</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  <span class="at">L =</span> <span class="dv">365</span>,</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>  <span class="at">n_start =</span> <span class="dv">1000</span>, <span class="at">n_step =</span> <span class="dv">250</span>, <span class="at">max_n_per_arm =</span> <span class="dv">5000</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>)</span></code></pre></div>
</details>
</div>
</div>
<div id="bootstrap-methods" class="section level2">
<h2>Bootstrap Methods</h2>
<p>The <code>.boot</code> suffix in function names indicates a
bootstrap, or simulation-based, approach, which provides a robust,
distribution-free alternative. This method repeatedly resamples from the
pilot data, fits the model on each sample, and calculates power as the
proportion of simulations where the treatment effect is significant.
While computationally intensive, it makes fewer assumptions.</p>
<div id="power-and-sample-size-calculation-.boot" class="section level3">
<h3>Power and Sample Size Calculation (<code>.boot</code>)</h3>
<p>Here is how you would call the bootstrap functions for power for the
linear model. The following examples use the same <code>veteran</code>
dataset, but with a smaller number of simulations for demonstration
purposes. In practice, a larger number of simulations (e.g., 1,000 or
more) is recommended to ensure stable results.</p>
<p>First we calculate the power for a range of sample sizes. The <a href="../reference/linear.power.boot.html"><code>linear.power.boot</code></a>
function takes the pilot data and returns a data frame with the
estimated power for each sample size.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>power_boot_vet <span class="ot">&lt;-</span> <span class="fu">linear.power.boot</span>(</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="at">pilot_data =</span> vet,</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  <span class="at">linear_terms =</span> <span class="st">&quot;karno&quot;</span>,</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">150</span>, <span class="dv">200</span>, <span class="dv">250</span>),</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>  <span class="at">L =</span> <span class="dv">365</span>,</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>  <span class="at">n_sim =</span> <span class="dv">200</span> </span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>)</span></code></pre></div>
</details>
<p>Here is how you would call the bootstrap function for sample size
calculation. We will use the function <a href="../reference/linear.ss.boot.html"><code>linear.ss.boot</code></a>
to find the sample size needed to achieve a target power of 0.5,
truncating at 180 days (6 months).</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>ss_boot_vet <span class="ot">&lt;-</span> <span class="fu">linear.ss.boot</span>(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="at">pilot_data =</span> vet,</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>  <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  <span class="at">target_power =</span> <span class="fl">0.5</span>,</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>  <span class="at">linear_terms =</span> <span class="st">&quot;karno&quot;</span>,</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>  <span class="at">L =</span> <span class="dv">180</span>,</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>  <span class="at">n_sim =</span> <span class="dv">500</span>, </span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>  <span class="at">patience =</span> <span class="dv">5</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>)</span></code></pre></div>
</details>
<hr />
</div>
</div>
</div>
<div id="additive-stratified-models" class="section level1 tabset">
<h1 class="tabset">Additive Stratified Models</h1>
<p>In multi-center clinical trials, it is often necessary to stratify
the analysis by a categorical variable with many levels, such as the
clinical center or a discretized biomarker. Estimating a separate
parameter for each stratum can be inefficient, particularly when the
number of strata is large. The additive stratified model elegantly
handles this situation by conditioning out the stratum-specific
effects.</p>
<div id="theory-and-model-1" class="section level2">
<h2>Theory and Model</h2>
<p>The semiparametric additive model for RMST, as developed by <span class="citation">(<a href="#ref-zhang2024">Zhang and Schaubel
2024</a>)</span>, is defined as: <span class="math display">\[\mu_{ij} =
\mu_{0j} + \beta&#39;Z_i\]</span> This model assumes that the effect of
the covariates <span class="math inline">\(Z_i\)</span> (which includes
the treatment arm) is <strong>additive</strong> and constant across all
strata <span class="math inline">\(j\)</span>. Crucially, it allows each
stratum to have its own unique baseline RMST, denoted by <span class="math inline">\(\mu_{0j}\)</span>.</p>
<p>The estimation of the common treatment effect, <span class="math inline">\(\beta\)</span>, is achieved efficiently through a
<strong>stratum-centering</strong> approach applied to IPCW-weighted
data. This method avoids the direct estimation of the numerous <span class="math inline">\(\mu_{0j}\)</span> parameters, making it
computationally efficient even with a large number of strata.</p>
</div>
<div id="analytical-methods-1" class="section level2">
<h2>Analytical Methods</h2>
<div id="sample-size-calculation---additive.ss.analytical" class="section level3">
<h3>Sample Size Calculation - <a href="../reference/additive.ss.analytical.html"><code>additive.ss.analytical</code></a></h3>
<p><strong>Scenario</strong>: We use the <code>colon</code> dataset to
design a trial stratified by the extent of local disease
(<code>extent</code>), a factor with 4 levels. We want to find the
sample size per stratum to achieve 80% power. Lets inspect the prepared
<code>colon</code> dataset.</p>
<p>Now, we run the sample size search for 80% power, truncating at 5
years (1825 days).</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>ss_results_colon <span class="ot">&lt;-</span> <span class="fu">additive.ss.analytical</span>(</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="at">pilot_data =</span> colon_death,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>, <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>, <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>, <span class="at">strata_var =</span> <span class="st">&quot;strata&quot;</span>,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="at">target_power =</span> <span class="fl">0.60</span>,</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="at">L =</span> <span class="dv">1825</span>,</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  <span class="at">n_start =</span> <span class="dv">100</span>, <span class="at">n_step =</span> <span class="dv">100</span>, <span class="at">max_n_per_arm =</span> <span class="dv">10000</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>)</span></code></pre></div>
</details>
</div>
<div id="power-calculation---additive.power.analytical" class="section level3">
<h3>Power Calculation - <a href="../reference/additive.power.analytical.html"><code>additive.power.analytical</code></a></h3>
<p>This function calculates the power for a given set of sample sizes in
a stratified additive model. We will use the <code>colon</code> dataset
again for this example.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>power_results_colon <span class="ot">&lt;-</span> <span class="fu">additive.power.analytical</span>(</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="at">pilot_data =</span> colon_death,</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  <span class="at">strata_var =</span> <span class="st">&quot;strata&quot;</span>,</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">1000</span>, <span class="dv">3000</span>, <span class="dv">5000</span>),</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="at">L =</span> <span class="dv">1825</span> <span class="co"># 5 years</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>)</span></code></pre></div>
</details>
<hr />
</div>
</div>
</div>
<div id="multiplicative-stratified-models" class="section level1 tabset">
<h1 class="tabset">Multiplicative Stratified Models</h1>
<p>As an alternative to the additive model, the multiplicative model may
be preferred if the treatment is expected to have a relative, or
proportional, effect on the RMST—for example, increasing or decreasing
survival time by a certain percentage.</p>
<div id="theory-and-model-2" class="section level2">
<h2>Theory and Model</h2>
<p>The multiplicative model, based on the work of <span class="citation">(<a href="#ref-wang2019">Wang et al. 2019</a>)</span>,
is defined as: <span class="math display">\[\mu_{ij} = \mu_{0j}
\exp(\beta&#39;Z_i)\]</span> In this model, the covariates <span class="math inline">\(Z_i\)</span> have a
<strong>multiplicative</strong> effect on the baseline stratum-specific
RMST, <span class="math inline">\(\mu_{0j}\)</span>. This structure is
equivalent to a linear model on the log-RMST.</p>
<p>While the formal estimation of <span class="math inline">\(\beta\)</span> requires a complex iterative
solver, this package uses a practical and computationally efficient
approximation. It fits a weighted log-linear model
(<code>lm(log(Y_rmst) ~ ...)</code>) to the data, which provides robust
estimates for the effect size (the log-RMST ratio) and its variance.</p>
</div>
<div id="analytical-methods-2" class="section level2">
<h2>Analytical Methods</h2>
<div id="power-calculation---ms.power.analytical" class="section level3">
<h3>Power Calculation - <a href="../reference/MS.power.analytical.html"><code>MS.power.analytical</code></a></h3>
<p>This function calculates the power for various sample sizes using the
analytical method for the multiplicative stratified model.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>power_ms_analytical <span class="ot">&lt;-</span> <span class="fu">MS.power.analytical</span>(</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> colon_death,</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>, <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>, <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>, <span class="at">strata_var =</span> <span class="st">&quot;strata&quot;</span>,</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>   <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">300</span>, <span class="dv">400</span>, <span class="dv">500</span>),</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">1825</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>)</span></code></pre></div>
</details>
</div>
<div id="sample-size-calculation---ms.ss.analytical" class="section level3">
<h3>Sample Size Calculation - <a href="../reference/MS.ss.analytical.html"><code>MS.ss.analytical</code></a></h3>
<p>The following example demonstrates the sample size calculation using
the same model.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>ms_ss_results_colon <span class="ot">&lt;-</span> <span class="fu">MS.ss.analytical</span>(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> colon_death, <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>, <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>, <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>, <span class="at">strata_var =</span> <span class="st">&quot;strata&quot;</span>,</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>   <span class="at">target_power =</span> <span class="fl">0.6</span>,<span class="at">L =</span> <span class="dv">1825</span>)</span></code></pre></div>
</details>
</div>
</div>
<div id="bootstrap-methods-1" class="section level2">
<h2>Bootstrap Methods</h2>
<p>The bootstrap approach provides a more robust, simulation-based
analysis for the multiplicative model.</p>
<div id="power-calculation---ms.power.boot" class="section level3">
<h3>Power Calculation - <a href="../reference/MS.power.boot.html"><code>MS.power.boot</code></a></h3>
<p>The following code demonstrates how to call the
<code>MS.power.boot</code> function.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>power_ms_boot <span class="ot">&lt;-</span> <span class="fu">MS.power.boot</span>(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> colon_death,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>   <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>   <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>   <span class="at">strata_var =</span> <span class="st">&quot;strata&quot;</span>,</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>   <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">300</span>, <span class="dv">500</span>),</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">1825</span>,</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>   <span class="at">n_sim =</span> <span class="dv">100</span>, </span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>   <span class="at">parallel.cores =</span> <span class="dv">10</span> </span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>)</span></code></pre></div>
</details>
</div>
<div id="sample-size-calculation---ms.ss.boot" class="section level3">
<h3>Sample Size Calculation - <a href="../reference/MS.ss.boot.html"><code>MS.ss.boot</code></a></h3>
<p>Similarly, the sample size can be calculated using bootstrap
simulation.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>ss_ms_boot <span class="ot">&lt;-</span> <span class="fu">MS.ss.boot</span>(</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> colon_death,</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>   <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>   <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>   <span class="at">strata_var =</span> <span class="st">&quot;strata&quot;</span>, </span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>   <span class="at">target_power =</span> <span class="fl">0.5</span>,</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">1825</span>,</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>   <span class="at">n_sim =</span> <span class="dv">100</span>,</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>   <span class="at">n_start =</span> <span class="dv">100</span>,</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>   <span class="at">n_step =</span> <span class="dv">50</span>,</span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>   <span class="at">patience =</span> <span class="dv">4</span>,</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>   <span class="at">parallel.cores =</span> <span class="dv">10</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>)</span></code></pre></div>
</details>
<hr />
</div>
</div>
</div>
<div id="semiparametric-gam-models" class="section level1 tabset">
<h1 class="tabset">Semiparametric GAM Models</h1>
<p>When a covariate is expected to have a non-linear effect on the
outcome (for example, the effect of age or a biomarker), standard linear
models may be misspecified. Generalized Additive Models (GAMs) provide a
flexible solution by modeling such relationships with smooth
functions.</p>
<div id="theory-and-model-3" class="section level2">
<h2>Theory and Model</h2>
<p>These functions use a bootstrap simulation approach combined with a
GAM. The method involves two main steps:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Jackknife Pseudo-Observations</strong>: The time-to-event
outcome is first converted into <strong>jackknife
pseudo-observations</strong> for the RMST. This technique, explored in
recent statistical literature for RMST estimation <span class="citation">(<a href="#ref-perdry2024"><strong>perdry2024?</strong></a>)</span>, creates
a continuous, uncensored variable that represents each subject’s
contribution to the RMST. This makes the outcome suitable for use in a
standard regression framework.</p></li>
<li><p><strong>GAM Fitting</strong>: A GAM is then fitted to these
pseudo-observations. The model has the form: <span class="math display">\[\mathbb{E}[\text{pseudo}_i] = \beta_0 + \beta_1
\cdot \text{Treatment}_i + \sum_{k=1}^{q}
f_k(\text{Covariate}_{ik})\]</span> Here, <span class="math inline">\(f_k()\)</span> are the non-linear <strong>smooth
functions</strong> (splines) that the GAM estimates from the
data.</p></li>
</ol>
<div id="power-calculation-formula-gam.power.boot" class="section level3">
<h3>Power Calculation Formula (<code>GAM.power.boot</code>)</h3>
<p>Because this is a bootstrap method, power is not calculated from a
direct formula but is instead estimated empirically from the
simulations: <span class="math display">\[\text{Power} = \frac{1}{B}
\sum_{b=1}^{B} \mathbb{I}(p_b &lt; \alpha)\]</span> Where:</p>
<ul>
<li><p><span class="math inline">\(B\)</span> is the total number of
bootstrap simulations (<code>n_sim</code>).</p></li>
<li><p><span class="math inline">\(p_b\)</span> is the p-value for the
treatment effect in the <span class="math inline">\(b\)</span>-th
simulation.</p></li>
<li><p><span class="math inline">\(\mathbb{I}(\cdot)\)</span> is the
indicator function, which is 1 if the condition is true and 0
otherwise.</p></li>
</ul>
</div>
</div>
<div id="bootstrap-methods-2" class="section level2">
<h2>Bootstrap Methods</h2>
<div id="power-calculation---gam.power.boot" class="section level3">
<h3>Power Calculation - <a href="../reference/GAM.power.boot.html"><code>GAM.power.boot</code></a></h3>
<p><strong>Scenario</strong>: We use the <code>gbsg</code> (German
Breast Cancer Study Group) dataset, suspecting that the progesterone
receptor count (<code>pgr</code>) has a non-linear effect on
recurrence-free survival. Here is a look at the prepared
<code>gbsg</code> data.</p>
<p>The following code shows how to calculate power.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>power_gam <span class="ot">&lt;-</span> <span class="fu">GAM.power.boot</span>(</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> gbsg_prepared,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;rfstime&quot;</span>,</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>   <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>   <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>   <span class="at">smooth_terms =</span> <span class="st">&quot;pgr&quot;</span>, <span class="co"># Model pgr with a smooth term</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>   <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">200</span>, <span class="dv">400</span>),</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">2825</span>, <span class="co"># 5 years</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>   <span class="at">n_sim =</span> <span class="dv">500</span>,</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>   <span class="at">parallel.cores =</span> <span class="dv">10</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="fu">print</span>(power_gam<span class="sc">$</span>results_plot)</span></code></pre></div>
</details>
</div>
<div id="sample-size-calculation---gam.ss.boot" class="section level3">
<h3>Sample Size Calculation - <a href="../reference/GAM.ss.boot.html"><code>GAM.ss.boot</code></a></h3>
<p><strong>Scenario</strong>: We want to find the sample size needed to
achieve 80% power for detecting an effect of <code>pgr</code> on
recurrence-free survival.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>ss_gam <span class="ot">&lt;-</span> <span class="fu">GAM.ss.boot</span>(</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> gbsg_prepared,</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;rfstime&quot;</span>,</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>   <span class="at">status_var =</span> <span class="st">&quot;status&quot;</span>,</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>   <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>   <span class="at">target_power =</span> <span class="fl">0.95</span>,</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">182</span>, </span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>   <span class="at">n_sim =</span> <span class="dv">500</span>, </span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>   <span class="at">patience =</span> <span class="dv">5</span>,</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>   <span class="at">parallel.cores =</span> <span class="dv">10</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>)</span></code></pre></div>
</details>
<hr />
</div>
</div>
</div>
<div id="dependent-censoring-models" class="section level1">
<h1>Dependent Censoring Models</h1>
<p>In some studies, particularly observational or registry studies,
censoring may not be independent of the event of interest. A classic
example is in transplant medicine, where receiving an organ transplant
removes a patient from being at risk of pre-transplant death. This is a
form of <strong>competing risk</strong>, which can also be viewed as
dependent censoring.</p>
<div id="theory-and-model-4" class="section level2">
<h2>Theory and Model</h2>
<p>The methods from <span class="citation">(<a href="#ref-wang2018">Wang
and Schaubel 2018</a>)</span> address this by extending the IPCW
framework. Instead of a single model for the overall censoring
distribution, <strong>cause-specific Cox models</strong> are fitted for
each of the <span class="math inline">\(K\)</span> sources of censoring
(e.g., one model for administrative censoring, another for the competing
event).</p>
<p>The final weight for a subject is then a product of the weights
derived from all censoring causes, calculated as: <span class="math display">\[W_i = \exp\left(\sum_{k=1}^{K}
\hat{\Lambda}_{k}(Y_i)\right)\]</span> where <span class="math inline">\(\hat{\Lambda}_{k}\)</span> is the estimated
cumulative hazard for censoring cause <code>k</code>, and <span class="math inline">\(Y_i = \min(T_i, L)\)</span> is the truncated event
time. The final analysis is a weighted linear regression on the
RMST.</p>
<div id="power-calculation-formula-dc.power.analytical" class="section level3">
<h3>Power Calculation Formula (<code>DC.power.analytical</code>)</h3>
<p>Power is calculated analytically using the standard formula: <span class="math display">\[\text{Power} = \Phi\left(
\frac{|\beta_{\text{effect}}|}{\sigma_N} - z_{1-\alpha/2}
\right)\]</span> The key difference in this model is that the variance,
<span class="math inline">\(\sigma_N^2\)</span>, is derived from a
robust sandwich estimator that properly accounts for the multiple
weighting components from the different cause-specific hazard
models.</p>
</div>
</div>
<div id="analytical-methods-3" class="section level2">
<h2>Analytical Methods</h2>
<p>We will use the <code>mgus2</code> dataset for this scenario.</p>
<div id="power-calculation---dc.power.analytical" class="section level3">
<h3>Power Calculation - <a href="../reference/DC.power.analytical.html"><code>DC.power.analytical</code></a></h3>
<p>This function calculates power for a study with dependent censoring
(competing risks) for a given set of sample sizes.</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>dc_power_results <span class="ot">&lt;-</span> <span class="fu">DC.power.analytical</span>(</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> mgus_prepared,</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>   <span class="at">status_var =</span> <span class="st">&quot;event_primary&quot;</span>,</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>   <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>   <span class="at">dep_cens_status_var =</span> <span class="st">&quot;event_dependent&quot;</span>,</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>   <span class="at">sample_sizes =</span> <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">250</span>, <span class="dv">500</span>),</span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>   <span class="at">linear_terms =</span> <span class="st">&quot;age&quot;</span>,</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">120</span> <span class="co"># 10 years</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>)</span></code></pre></div>
</details>
</div>
<div id="sample-size-calculation---dc.ss.analytical" class="section level3">
<h3>Sample Size Calculation - <a href="../reference/DC.ss.analytical.html"><code>DC.ss.analytical</code></a></h3>
<p>Now, find the sample size needed for 80% power, truncating at 10
years (120 months).</p>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>ss_dc_mgus <span class="ot">&lt;-</span> <span class="fu">DC.ss.analytical</span>(</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>   <span class="at">pilot_data =</span> mgus_prepared,</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>   <span class="at">time_var =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>   <span class="at">status_var =</span> <span class="st">&quot;event_primary&quot;</span>,</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>   <span class="at">arm_var =</span> <span class="st">&quot;arm&quot;</span>,</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>   <span class="at">dep_cens_status_var =</span> <span class="st">&quot;event_dependent&quot;</span>,</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>   <span class="at">target_power =</span> <span class="fl">0.80</span>,</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>   <span class="at">linear_terms =</span> <span class="st">&quot;age&quot;</span>,</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>   <span class="at">L =</span> <span class="dv">120</span>, <span class="co"># 10 years</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>   <span class="at">n_start =</span> <span class="dv">100</span>, <span class="at">n_step =</span> <span class="dv">50</span>, <span class="at">max_n_per_arm =</span> <span class="dv">5000</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>)</span></code></pre></div>
</details>
</div>
</div>
</div>
<div id="interactive-shiny-application" class="section level1">
<h1>Interactive Shiny Application</h1>
<p>For users who prefer a graphical interface, <code>RMSTSS</code>
provides an interactive Shiny web application that offers a
point-and-click interface to all the models and methods described in
this vignette.</p>
<div id="accessing-the-application" class="section level3">
<h3>Accessing the Application</h3>
<p>There are two ways to access the application:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Live Web Version (Recommended)</strong>: Access the
application directly in your browser without any installation.</p>
<ul>
<li><a href="https://arnab96.shinyapps.io/uthsc-app/">Launch Web
Application</a></li>
</ul></li>
<li><p><strong>Run Locally from the R Package</strong>: If you have
installed the <code>RMSTSS-Package</code>, you can run the application
on your own machine with the following command:</p></li>
</ol>
<details class="chunk-details"><summary class="chunk-summary"><span class="chunk-summary-text">Code</span></summary>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>RMSTSS<span class="sc">::</span><span class="fu">run_app</span>()</span></code></pre></div>
</details>
</div>
<div id="app-features" class="section level3">
<h3>App Features</h3>
<ul>
<li><strong>Interactive Data Upload</strong>: Upload your pilot dataset
in <code>.csv</code> format.</li>
<li><strong>Visual Column Mapping</strong>: Visually map the columns in
your data to the required variables for the analysis (e.g., time,
status, treatment arm).</li>
<li><strong>Full Model Selection</strong>: Choose the desired RMST
model, calculation method (analytical or bootstrap), and set all
relevant parameters through user-friendly controls.</li>
<li><strong>Rich Visualization</strong>: Execute the analysis and view
the results, including survival plots, power curves, and summary tables,
all within the application.</li>
<li><strong>Downloadable Reports</strong>: Generate and download a
complete, publication-ready analysis report in PDF format.</li>
</ul>
</div>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>The <code>RMSTSS</code> package provides a powerful and flexible
suite of tools for designing and analyzing clinical trials using the
Restricted Mean Survival Time.</p>
<div id="advantages-and-disadvantages" class="section level2">
<h2>Advantages and Disadvantages</h2>
<ul>
<li><strong>Advantages</strong>: The package implements a wide range of
modern statistical methods, allowing users to handle complex scenarios
like stratification, non-linear effects, and competing risks. The
provision of both fast analytical methods and robust bootstrap methods
gives users a choice between speed and distributional flexibility.</li>
<li><strong>Disadvantages</strong>: The primary limitation is the
reliance on representative pilot data. The accuracy of any power or
sample size calculation is contingent on the effect sizes and variance
structures estimated from the pilot dataset. Furthermore, the
bootstrap-based methods can be computationally intensive and may require
access to parallel computing resources for timely results.</li>
</ul>
</div>
<div id="future-work" class="section level2">
<h2>Future Work</h2>
<p>Future development could involve extending the bootstrap approach to
the dependent censoring models and incorporating more advanced model
diagnostic tools to help users assess the adequacy of their chosen model
based on the pilot data.</p>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-royston2013" class="csl-entry">
Royston, Patrick, and Mahesh KB Parmar. 2013. <span>“Restricted Mean
Survival Time: An Alternative to the Hazard Ratio for the Design and
Analysis of Randomized Trials with a Time-to-Event Outcome.”</span>
<em>BMC Medical Research Methodology</em> 13 (1): 1–13.
</div>
<div id="ref-tian2014" class="csl-entry">
Tian, Lu, Lihui Zhao, and LJ Wei. 2014. <span>“Predicting the Restricted
Mean Event Time with the Subject’s Baseline Covariates in Survival
Analysis.”</span> <em>Biostatistics</em> 15 (2): 222–33.
</div>
<div id="ref-uno2014" class="csl-entry">
Uno, Hajime, Brian Claggett, Lu Tian, Eisuke Inoue, P-Ralph Gallo, Tomoo
Miyata, Deborah Schrag, et al. 2014. <span>“Moving Beyond the Hazard
Ratio in Quantifying the Between-Group Difference in Survival
Analysis.”</span> <em>Journal of Clinical Oncology</em> 32 (22): 2380.
</div>
<div id="ref-wang2018" class="csl-entry">
Wang, Xin, and Douglas E Schaubel. 2018. <span>“Modeling Restricted Mean
Survival Time Under General Censoring Mechanisms.”</span> <em>Lifetime
Data Analysis</em> 24: 176–99.
</div>
<div id="ref-wang2019" class="csl-entry">
Wang, Xin, Yingchao Zhong, Purna Mukhopadhyay, and Douglas E Schaubel.
2019. <span>“Computationally Efficient Inference for Center Effects
Based on Restricted Mean Survival Time.”</span> <em>Statistics in
Medicine</em> 38 (27): 5133–45.
</div>
<div id="ref-zhang2024" class="csl-entry">
Zhang, Yuan, and Douglas E Schaubel. 2024. <span>“Semiparametric
Additive Modeling of the Restricted Mean Survival Time.”</span>
<em>Biometrical Journal</em> 66 (6): e202200371.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
